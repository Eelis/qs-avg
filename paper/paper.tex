\documentclass[runningheads]{llncs}

\newcommand{\theauthors}{James McKinna and Eelis van der Weegen}
\newcommand{\thetitle}{A Machine-checked Proof of the Average-case Complexity of Quicksort in Coq}

\usepackage{color}
\usepackage[colorlinks,pdftitle={dus},pdfauthor=\theauthors]{hyperref}

\spnewtheorem*{propo}{Proposition}{\bfseries}{\rmfamily}

%include polycode.fmt

%format pipe = "\mathopen{|}"

%format times = "\times"

%format . = "."
%format forall = "\forall"
%format Fixpoint = "\mathbf{Fixpoint}"
%format Definition = "\mathbf{Definition}"
%format Eval = "\mathbf{Eval}"
%format Notation = "\mathbf{Notation}"
%format Lemma = "\mathbf{Lemma}"
%format Proof = "\mathbf{Proof}"
%format Defined = "\mathbf{Defined}"
%format Function = "\mathbf{Function}"
%format Proposition = "\mathbf{Proposition}"
%format Record = "\mathbf{Record}"
%format Program = "\mathbf{Program}"
%format Inductive = "\mathbf{Inductive}"
%format Theorem = "\mathbf{Theorem}"
%format Let = "\mathbf{Let}"
%format Variable = "\mathbf{Variable}"
%format Variables = "\mathbf{Variables}"
%format measure = "\mathbf{measure}"

%format fcmp = "\circ"
%format match = "\mathbf{match}"
%format with = "\mathbf{with}"
%format end = "\mathbf{end}"
%format fun = "\lambda\hspace{-1mm} "
%format nat = "\mathbb{N}"
%format R = "\mathbb{R}"
%format exists = "\exists "
%format log2ceil = "\log_{2}\hspace{-0.5mm}"
%format over = "\mathbf{over}"
%format INR (a) = a
%format /\ = "\wedge "
%format \/ = "\vee"
%format <-> = "\leftrightarrow "
%format MonoidMonadTrans.M = "\Varid{MMT}"
%format NatAddMonoid = (nat, 0, +)

%format sqrd (a) = (a)"^2"

%format `In` = "\in"
%format `NotIn` = "\notin"

%format C_MMT
%format ret_MMT
%format bind_MMT

%format NeTreeMonad = "M_\Varid{ne\_tree}"
%format M_ne_tree = "M_\Varid{ne\_tree}"
%format bind_ne_tree = "\Varid{bind}_\Varid{ne\_tree}"
%format ret_ne_tree = "\Varid{ret}_\Varid{ne\_tree}"
%format pick_ne_tree = "\Varid{pick}_\Varid{ne\_tree}"

%format Monoid_U
%format cmp_U
%format pick_U
%format partition_U
%format qs_U
%format U.qs = "\Varid{qs}_U"

%format M_NDP
%format le_NDP
%format qs_NDP

%format le_SP
%format ret_SP
%format bind_SP
%format qs_SP

% todo:
% - check that names are spelled and encoded right in bibliography
% - lhs2tex shows parameters declared with {...} differently from those declared with (...)
% - mention that we don't do correctness proofs (although we can add them in the formalization, of course)
% - decide whether to hide, ignore, or explain R/N differences. explaining costs precious space. ignoring is "begging the question". hiding is naughty.
% - have a sentence somewhere hinting at the complications caused by duplicate elements (e.g., by pointing out simplifications that hold only with the assumption of no duplicate elements).

\def\commentbegin{\quad\{\ }
\def\commentend{\}}

\def\typeset{}

\usepackage{macros}

\newcommand{\todo}[1]{\textcolor{magenta}{[TODO: #1]}}

\begin{document}

\nocite{*}

\title{\thetitle}

\authorrunning{\em}
\titlerunning{\em}

\author{\theauthors}

\institute{Department of Computer Science, University of Nijmegen, the Netherlands}

\maketitle

\begin{abstract}
  \input{abstract.ltx}
\end{abstract}

\section{Introduction}

Proofs of the $O(n \log n)$ average-case complexity of Quicksort \cite{HoareQuick} are included in many textbooks on computational complexity \cite[for example]{introtoalgos}.
This paper documents what the authors believe to be the first fully formal machine-checked version of such a proof, developed using the Coq proof assistant \cite{coq}.

The formalization is based on the ``paper proof'' in \cite{introtoalgos}, which consists of three parts. The first part argues that the total number of comparisons performed by the algorithm can be written as the sum of the expected number of comparisons between individual pairs of elements from the input list (ordered a certain way). The second part then derives from the algorithm a specific formula for this expectancy. Finally, the third and last part employs some analysis involving the harmonic series to derive the $O(n \log n)$ bound from the sum-of-expectancies. Thus, the first part essentially establishes a lemma about the expected number of comparisons between individual pairs of elements from the input list as an interface between the second and third part, proved by the former and used by the latter.

Of these three parts, only the first two require reasoning about the actual behavior of the algorithm---the third part is just ordinary mathematics. While the original proof provides a thorough treatment of the third part, its treatment of the first two parts is informal in two major ways.

First, it never actually justifies anything in terms of the algorithm's formal semantics. Indeed, it does not even formally define the algorithm in the first place. Instead, it relies on assertions which are taken to be intuitively true. While this practice is common and perfectly reasonable for paper proofs intended for human consumption, it is a luxury we do not afford ourselves.

Second, the original proof (implicitly) assumes that the input list does not contain any duplicate elements, which significantly simplifies its derivation of the formula for the probability of any two given elements being compared by the algorithm. We do not make this assumption.
  % todo: bring this up later.

The key to giving a proper formal treatment of both of these issues lies in the use of an appropriate representation of the algorithm, capable of capturing its computational behavior---specifically, its use of comparisons---in a way suitable for subsequent formal reasoning. The representation we use takes the form of a shallow monadic embedding, in which the algorithm is written as a monadically expressed functional program. This definition is then instantiated with refinements of operation-counting monads to make the number of comparisons performed observable.

The embedding is introduced in section \ref{embed}, where we demonstrate its use by first defining a simple deterministic Quicksort implementation (which just selects the head of the input list as its pivot element, and uses two separate filter passes to partition the input list), and then defining an operation counting monad that lets us prove that implementation's quadratic worst-case complexity.

In preparation of the more complex average-case theorem, we then define (in section \ref{nondetexpec}) a nondeterministic Quicksort implementation which selects pivot elements at random, and which uses a single three-way partition pass instead of a two two-way filter passes. We also introduce a monad that combines operation counting with nondeterminism, supporting a formal definition of the notion of the \emph{expected} number of comparisons that are performed.

Instantiating the nondeterministic implementation with this monad then lets us state the main theorem in section \ref{statement}.

The next two sections detail the actual formalized proof. Section \ref{reduction} corresponds to the first part in the original proof, and shows how the main theorem can be split up into a lemma (stated in terms of another special-purpose monad) about the expected number of comparisons being performed for pairs of input elements indexed a certain way, and a strictly numerical part.

Since we were able to fairly directly transcribe the latter part from the paper proof, using the existing real-number theory in the Coq standard library with few complications and additions, we omit a discussion of it in this paper and refer the interested reader to the paper proof.

Section \ref{finishing} shows the proof of the lemma mentioned above, and corresponds to the part in the original proof that derives the expectancy formula from the algorithm. Since this is the part where the original proof omits the most detail, and makes the assumption regarding duplicate elements, and where we really have to reason in detail about the behavior of the algorithm, it is by far the most involved part of the formalization.

Section \ref{conclusion} ends with conclusions and final remarks.

The Coq source files containing the entire formalization can be downloaded from \url{http://www.eelis.net/research/quicksort/}. The Coq version used is 8.2 beta 2.

\section{A Shallow Monadic Embedding}
\label{embed}

% todo: less pompous here \/

As stated before, the key to giving a proper formal treatment of those parts of the proof for which the original contents itself with appeals to intuition, lies in the use of an appropriate representation of the algorithm. Indeed, we cannot even formally state the main theorem until we have both an algorithm definition and the means to denote its use of comparisons (the usual complexity metric for sorting algorithms).

Since we are working in Coq, we already have at our disposal a full functional programming language, in the form of Coq's pCIC \cite{coq'art}. However, just writing the algorithm as an ordinary Coq function would not let us observe its use of comparisons. We make those uses observable by writing the algorithm as a monadically expressed function, parameterizing it on both the monad itself and on the comparison operation. Expressed this way, a deterministic quicksort that simply selects the head of the input list as its pivot element, and uses two simple filter passes to partition the input list, looks as follows:

\begin{code}
  Variables (M: Monad) (T: Set) (le: T -> T -> M bool).

  Definition gt (x y: T): M bool := liftM negb (le x y).

  Fixpoint filter (c: T -> M bool) (l: list T): M (list T) :=
    match l with
    | nil => ret nil
    | h :: t =>
      t' <- filter c t;
      b <- c h;
      ret (if b then h :: t' else t')
    end.

  Program Fixpoint qs (l: list T) {measure length l}: M (list T) :=
    match l with
    | nil => ret nil
    | pivot :: t =>
        lower <- filter (gt pivot) t >>= qs;
        upper <- filter (le pivot) t >>= qs;
        ret (lower ++ pivot :: upper)
    end.
\end{code}
|Monad| is a dependent record containing the (coercible) carrier of type |Set -> Set|, along with |bind| (infix: |>>=|) and |ret| (for ``return'') operations, and the three monad laws. For a general introduction to monadic programming and monad laws, see \cite{wadler93monads}. The notation ``|x <- y; z|'', shorthand for |y >>= \x => z| (where |x| may occur in |z|) is known as ``do-notation''.

We use Coq's |Program| facility \cite{subsetcoercions} to cope with the fact that Quicksort's recursion is non-structural, by using the input list length as a measure. The proof obligations generated by |Program| for the above definition and measure are trivial enough for Coq to prove mostly by itself.

By instantiating the above definitions with the right monad, we can transparently insert comparison-counting instrumentation into the algorithm, which will prove to be sufficient to let us reason about its complexity. But before we do so, let us note that if the above definitions are instead instantiated with the identity monad and an ordinary elementwise comparison on |T|, then the monadic scaffolding melts away, and the result is equivalent to an ordinary non-instrumented, non-monadic version, suitable for extraction and correctness proofs. This means that while we will instantiate the definitions with less trivial monads to support our complexity proofs, we can take some comfort in knowing that the object of those proofs is, in a very concrete sense, the actual Quicksort algorithm (as one would write it in a functional programming language), rather than some idealized model thereof.

For reasons that will become clear in later sections, we compose the monad we will instantiate the above definitions with using a monad transformer called |MMT| (for ``monoid monad transformer''), which piggybacks a monoid onto an existing monad by pairing.

\begin{code}
  Variables (monoid: Monoid) (monad: Monad).

  Let C_MMT (T: Set): Set := monad (monoid * T).

  Let ret_MMT (T: Set): T -> C_MMT T := ret fcmp pair (monoid_zero monoid).

  Let bind_MMT (A B: Set) (a: C_MMT A) (ab: A -> C_MMT B): C_MMT B :=
    x <- a; y <- ab (snd x); ret (monoid_mult monoid (fst x) (fst y), snd y).

  Definition MMT: Monad := Build_Monad C_MMT bind_MMT ret_MMT.
\end{code}
(In the interest of brevity, we omit proofs of the monad laws for |MMT| and all other monads defined in this paper. These proofs can all be found in the Coq code.)

We now use |MMT| to piggyback the additive monoid on |nat| onto the identity monad, and lift elementwise comparison into the resulting monad, which we call |SP| (for ``simply-profiled'').
\begin{code}
  Definition SP: Monad := MMT NatAddMonoid IdMonad.

  Definition le_SP (x y: nat): SP bool := (1, le x y).
\end{code}
When instantiated with this monad and comparison operation, |qs| produces the comparison count as part of its result.
\begin{code}
  Definition qs_SP := qs SP le_SP.

  Eval compute in qs_SP (3 :: 1 :: 0 :: 4 :: 5 :: 2 :: nil).
    = (16, 0 :: 1 :: 2 :: 3 :: 4 :: 5 :: nil)
\end{code}
Defining |cost| and |result| as the first and second projection, respectively, we have the identities
\begin{code}
  forall x, cost (ret_SP x) = 0,
  forall x f, cost (bind_SP x f) = cost x + cost (f (result x),
  forall x y, cost (le_SP x y) = 1.
\end{code}
This very modest amount of machinery is sufficient for a straightforward proof of Quicksort's quadratic worst-case complexity.

\begin{propo}|qs_worst: forall l, cost (qs_SP l) <= sqrd (length l).|\footnote{(We don't use big-$O$ notation for this simple statement, as it would only obfuscate. Big-$O$ complexity is discussed in section \ref{statement}.)}
\end{propo}

\begin{proof}
  The proof is by induction matching |qs|'s recursion. For an empty input list, we have |cost (qs_SP nil) = cost (ret nil) = 0 <= sqrd (length l)|. For a non-empty input list |(pivot :: t)|, the cost decomposes into
  \begin{code}
    cost (filter (le pivot) t) + cost (qs_SP (result (filter (lt pivot) t))) +
    cost (filter (gt pivot) t) + cost (qs_SP (result (filter (gt pivot) t))) +
    cost (ret (result (qs_SP (result (filter (lt pivot) t))) ++
     pivot :: result (qs_SP (result (filter (gt pivot) t))))).
  \end{code}
  The |filter| costs are easily proved (by induction on |t|) to be |length t| each. The cost of the final |ret| is 0 by definition. The induction hypothesis applies to the recursive |qs_SP| calls. Furthermore, by induction on |t|, we can easily prove
  \begin{code}
  length (result (filter (le pivot) t)) +
  length (result (filter (gt pivot) t)) <= length t,
  \end{code}
  because the two predicates filtered on are mutually exclusive. Abstracting |filter (le pivot) t| and its |gt| counterpart, this leaves
  \begin{code}
    forall (t flt flt': list T), length flt + length flt' <= length t ->
      length t + sqrd (length flt) + length t + sqrd (length flt') + 0 <= sqrd (S (length t)),
  \end{code}
  which is true by elementary arithmetic. \qed
\end{proof}

We now expand the technique in preparation of the average-case complexity proof.

\section{Nondeterminism and Expected Values}
\label{nondetexpec}

The Quicksort algorithm used by the average-case proof we formalize differs from the one presented in the last section in two ways. First, it selects a pivot element nondeterministically, thereby avoiding the pathological quadratic cases any deterministic pivot selection strategy inevitably suffers. Second, it uses a single three-way partition pass instead of two two-way filter passes, to avoid the pathological quadratic case that two two-way filter passes suffer for an input list consisting of elements all of the same value.

Combined, these two traits ensure that the $O(n \log n)$ average-case bound holds not just averaged over all input lists, but for each individual input list as well. This greatly simplifies things, because it means that the global bound can be proved simply by proving it as a bound of the expected number of comparisons performed for an arbitrary input.

Hence, we now modify our |qs| definition to use a three-way partition pass, and to use nondeterministic pivot selection. Following that, we will compose a new monad (again using |MMT|, but this time transforming a nondeterminism monad) that the new definition can be instantiated with to capture its \emph{expected} number of comparisons.

First, we define |partition|. Instead of a two-way comparison operation producing a monadic |bool|, it takes a three-way comparison operation producing a monadic |comparison|, which is an enumeration with values |Lt|, |Eq|, and |Gt|. |partition| constructs a |Partitioning T|, which is simply a function of type |comparison -> list T|. We might equally well have used an inductive definition of |Partitioning T| as a record containing three lists. % at least until i remember why i used a function.

\parbox{\textwidth}{\begin{code}
  Variables (T: Set) (M: Monad) (cmp: T -> T -> M comparison).

  Fixpoint partition (pivot: T) (l: list T): M (Partitioning T) :=
    match l with
    | nil => ret emptyPartitioning
    | h :: t =>
        b <- cmp h pivot;
        tt <- partition pivot t ;
        ret (addToPartitioning b h tt)
    end.
\end{code}}

Next, we redefine |qs| to use |partition|, and have it take as an additional parameter a |pick| operation, representing nondeterministic selection of an element of a non-empty list of choices. (An |ne_list T| is a non-empty list of |T|'s.)

\begin{code}
  Variable pick: forall (A: Set), ne_list A -> M A.

  Program Fixpoint qs (l: list T) {measure length l}: M (list T) :=
    match l with
    | nil => ret nil
    | _ =>
        i <- pick [0 ... length l - 1];
        let pivot := nth l i in
        part <- partition pivot (remove l i);
        low <- qs (part Lt);
        upp <- qs (part Gt);
        ret (low ++ pivot :: part Eq ++ upp)
    end.
\end{code}
The functions |nth| and |remove| select and remove the $n$th element of a list, respectively.

Nondeterminism can now be achieved by instantiating these definitions with a suitable monad, along with a corresponding |pick| operation. A deterministic, non-instrumented version can still be obtained, simply by instantiating the definitions with the identity monad and a corresponding deterministic |pick| operation, like |head|.

Let us now consider what kind of nondeterminism monad would be suitable for reasoning about the expected value of a nondeterministic program. The list monad is commonly used to emulate nondeterministic computation. With the list monad, the program
\begin{code}
  x <- pick [0, 1]; if x = 0 then ret 0 else pick [1, 2],
\end{code}
produces |[0, 1, 2]| as its list of possible outcomes. Unfortunately, the information that 0 is a more likely outcome than 1 or 2, has been lost. Such relative probabilities are critical to the notion of an expected value: the expected value of the program above is |avg [0, avg [1, 2]] = {-"\frac{3}{4}"-} /= 1 = avg [0, 1, 2]|. This makes list nondeterminism unsuitable for our purposes.

Using tree nondeterminism instead solves the problem.
\begin{code}
  Inductive ne_tree (T: Set): Set :=
    | Leaf: T -> ne_tree T
    | Node: ne_list (ne_tree T) -> ne_tree T.

  Definition ret_ne_tree {A: Set}: A -> ne_tree A := Leaf.

  Fixpoint bind_ne_tree (A B: Set) (m: ne_tree A) (k: A -> ne_tree B): ne_tree B :=
    match m with
    | Leaf a => k a
    | Node ts => Node (ne_list.map (fun x => bind_ne_tree x k) ts)
    end.

  Definition M_ne_tree: Monad := Build_Monad ne_tree bind_ne_tree ret_ne_tree.

  Definition pick_ne_tree (T: Set): ne_list T -> M_ne_tree T
    := Node fcmp ne_list.map Leaf.
\end{code}
We use non-empty trees because we do not consider partial functions, and using potentially empty trees would complicate the definition of a tree's average value below. This is also why we used |ne_list| for |pick|.

With this monad and pick operation, the same program now produces the tree |Node [Leaf 0, Node [Leaf 1, Leaf 2]]|, which preserves the relative probabilities. The expected value now coincides with the weighted average of these trees:
\begin{code}
  Definition ne_tree.avg: ne_tree R -> R := ne_tree.fold id ne_list.avg.
\end{code}

Relative probabilities are also the reason we use an $n$-ary choice primitive rather than a binary one, because correctly emulating (that is, without skewing the relative probabilities) an $n$-ary choice by a sequence of binary choices is only possible when $n$ is a power of two.

To denote the expected value of a \emph{measure} of the output of a program, we define

\begin{code}
  Definition expec (T: Set) (f: T -> nat): ne_tree T -> R
    := ne_tree.avg fcmp ne_tree.map f.
\end{code}

Thus, given a program |P| of type |M_ne_tree (list bool)|, |expec length P| denotes the expected length of the result list, if we interpret values of type |M_ne_tree T| as nondeterministically computed values of type |T|.

|expec| gives rise to a host of identities, including

\begin{code}
  0 <= expec f t
  expec (fun x => f x + g x) t = expec f t + expec g t.
  expec ((* c) fcmp f) = (* c) fcmp expec f

  (forall x `In` t -> f x <= g x) -> expec f t <= expec g t.
  (forall x `In` t -> f x = c) -> expec f t = c
  (forall x, x `In` t -> f x = 0) <-> expec f t = 0

  expec f (t >>= (ret fcmp g)) = expec (f fcmp g) t = expec f (ne_tree.map g t)
\end{code}

To form the monad with which we will instantiate |qs| for the main theorem, we now piggyback the additive monoid on |nat| onto |M_ne_tree| using |MMT|, and call the result |NDP| (for ``nondeterministically profiled''):
\begin{code}
  Definition M_NDP: Monad := MMT NatAddMonoid M_ne_tree.

  Definition le_NDP (x y: T): M bool := ret_ne_tree (1, le x y).

  Definition qs_NDP := qs M_NDP le_NDP (lift pick_ne_tree).
\end{code}
We can now denote the expected number of comparisons of a |qs_NDP| application by |expec cost (qs_NDP l)|, and will use this in our statement of the main theorem in the next section.

But before we do so, we define a slight refinement of |expec| that specifically observes the monoid component of computations in monads formed by transforming |M_ne_tree| using |MMT| (like |NDP|).
\begin{code}
  Definition monoid_expec (m: Monoid) (f: m -> nat) {A: Set}
    : (MonoidMonadTrans.M m NeTreeMonad A) -> R := expec (f fcmp fst).
\end{code}
Since |cost = fst|, we have |forall t, expec cost t = monoid_expec id t|.

In addition to all the identities |monoid_expec| inherits from |expec|, it has some of its own. One identity states that if one transforms |M_ne_tree| using a monoid |m|, then for a monoid homomorphism |h| from |m| to the additive monoid on |nat|, |monoid_expec h| distributes over |bind|, provided that the expected monoid value of the right hand side does not depend on the computed value of the left hand side:

\parbox{\textwidth}{\begin{code}
  monoid_expec_plus: forall (m: Monoid) (h: m -> nat) (A B: Set)
    (f: MMT m NeTreeMonad A) (g: A -> MMT m NeTreeMonad B):
    (forall x y `In` f -> monoid_expec h (g (snd x)) = monoid_expec h (g (snd y))),
    monoid_expec h (f >>= g) =
      monoid_expec h f + monoid_expec h (g (snd (ne_tree.head f))).
\end{code}}

Since |id| is a monoid homomorphism, |monoid_expec_plus| applies to |NDP| and |expec cost|. In section \ref{reduction}, we will use |monoid_expec_plus| with another monoid and homomorphism.

\section{The Statement}
\label{statement}

The last thing needed before the main theorem can be stated, is the notion of big-O complexity. The definition we use is a standard textbook definition, except that we work with a separate measure function parameter:

\parbox{\textwidth}{\begin{code}
  Definition measured_bigO (X: Set)
    (m: X -> nat) (f: X -> R) (g: nat -> R): Prop
      := exists c, exists n, forall x, n <= m x -> f x <= c * g (m x).

  Notation {-"``"-}over m ,{-"\ "-} f =O( g ){-"\text{''''}"-} := (measured_bigO m f g).
\end{code}}
We now state the main theorem.
\begin{code}
  Theorem qs_avg: over length,
    expec cost fcmp qs_NDP =O(fun n => INR (n * log2ceil n)).
\end{code}
Thanks to the property discussed at the start of the previous section, % perhaps too far back
the above follows as a corollary from the (slightly stronger) statement that
\begin{code}
  Theorem qs_expec_cost:
    forall l, expec cost (qs_NDP l) <= 2 * length l * S (log2ceil (length l)),
\end{code}
the proof of which is described in the remainder of this paper.

\section{Reduction to Pairwise Comparison Counts}
\label{reduction}

The main idea in the proof is to reduce |qs_expec_cost| to a statement about the expected number of comparisons between specific pairs of elements from the input list.

If $X \equiv X_{I_0} \ldots X_{I_{n-1}}$ is the input list, with $I$ a permutation of |[0 ... n-1]| such that $X_0 \ldots X_n$ is sorted, then the expected number of comparisons between any $X_i$ and $X_j$ with $i < j$ is at most $2 / S (j - i)$. In other words, the expected number of comparisons between two list elements is bounded by a simple function of the number of list elements that separate the two in the sort order. We prove this fact in the next section, but first show how |qs_expec_cost| follows from it.

Combined with the observation that the total expected number of comparisons equals the sum of the expected numbers of comparisons for each |(i, j)| in $\Varid{IJ} := \{ (i, j) \in [0, |length l|) \mid i < j \}$, the property described above suggests breaking up the inequality into
\begin{code}
  expec cost (qs_NDP l) <= {-"\displaystyle{\sum_{(i, j) \in \Varid{IJ}}\frac{2}{S (j - i)}}"-} <= 2 * length l * S (log2ceil (length l)).
\end{code}
Proving the right inequality requires a bit of analysis involving the harmonic series. This part of the proof could be fairly directly transcribed from the paper proof, using the existing real-number theory in the Coq standard library, with few complications and additions. We refer the interested reader to the paper proof.

The left inequality is the challenging one. To bring it closer to the index summation, we first rewrite
\begin{code}
  expec cost (qs_NDP l) = expec cost (qs_NDP (map (nth (sort l)) li)),
\end{code}
where |sort| may be any sorting function (including |qs| itself), and where |li| is a permutation of |[0...n - 1]| such that |map (nth (sort l)) li = l| (such an |li| can easily be proven to exist).

Next, we introduce a specialized monad and comparison operation that go one step further in focusing specifically on these indices.
\begin{code}
  Definition Monoid_U: Monoid := (list (nat * nat), nil, ++).

  Definition U: Monad := MonoidMonadTrans.M Monoid_U NeTreeMonad.

  Definition lookup_cmp (x y: nat): comparison :=
    cmp (nth (sort l) x) (nth (sort l) y).

  Definition cmp_U (x y: nat): U comparison :=
    ret ((if x <= y then (x, y) else (y, x)) :: nil, lookup_cmp x y).

  Definition qs_U: list nat -> list nat := qs cmp_U pick_U.
\end{code}
|qs_U| operates directly on a list of natural numbers representing indices into |sort l|. Comparison of indices is defined by comparison of the |T| values they denote in |sort l|. Furthermore, rather than producing a grand total comparison count the way |NDP| does, |U| records every pair of compared indices, by using |MMT| with |Monoid_U|, the free monoid over |nat * nat| pairs, instead of the additive monoid on |nat| we used up until now.

The goal can now be rewritten using
\begin{code}expec cost (qs_NDP (map (nth (sort l)) li))
  = monoid_expec length (qs_U li) = expec (length fcmp fst) (qs_U li).
\end{code}
The first equality expresses that the expected number of comparisons counted by |NDP| is equal to the expected length of the list of comparisons recorded by |U|. In the code, it is proved as a separate lemma by induction matching either side's |qs|'s recursion. The second equality merely unfolds the definition of |monoid_expec|.

After rewriting with the last of the identities listed for |expec| in section \ref{nondetexpec}, the goal becomes
\begin{code}
  expec length (ne_tree.map fst (qs_U li)) <= {-"\displaystyle{\sum_{(i, j) \in \Varid{IJ}}\frac{2}{S (j - i)}}"-}.
\end{code}
We now invoke another lemma which bounds a nondeterministically computed list's expected length by the expected number of occurrences of specific values in that list. More specifically, it states that

\parbox{\textwidth}{\begin{code}
  forall (X: Set) (fr: X -> R) (q: list X) (t: ne_tree (list X)):
    (forall x `In` q, expec (count x) t <= fr i) ->
    (forall x `NotIn` q, expec (count x) t = 0) ->
    NoDuplicates q -> expec length t <= {-"\displaystyle{\sum_{\Varid{i} \in \Varid{q}}\Varid{fr}\ \Varid{i}}"-}.
\end{code}}
It is trivially the case that |IJ| does not contain duplicate values. The second subgoal generated is\begin{code}forall (i, j) `NotIn` IJ, expec (count (i, j)) (ne_tree.map fst (qs_U li)) = 0.\end{code} Rewriting this using  the last of the identities listed for |expec| in section \ref{nondetexpec} in reverse, then rewriting the |expec| as a |monoid_expec|, and then generalizing the premise, results in the following property which is useful in its own right, as we will see later.
\begin{code}sound_cmp_expec_0: forall i j li, (i `NotIn` li \/ j `NotIn` li) ->
  monoid_expec (count (i, j)) (U.qs li) = 0,\end{code}
The proof of |sound_cmp_expec_0|, which we won't show here, is by a separate induction matching |qs|'s recursion.

This leaves but one subgoal which, expressed with |monoid_expec|, reads
\begin{code}
  forall (i, j) `In` IJ, monoid_expec (count (i, j)) (qs_U li) <= 2 / INR (S (j - i)).
\end{code}
This is exactly  to the property described at the beginning of this section. We prove it in the next section.

\section{Finishing the Proof}
\label{finishing}

To get a stronger induction hypothesis, we slightly generalize the goal to
\begin{code}
  forall i j, i < j -> forall (li: list nat) (b: nat), IndexSeq b li ->
    monoid_expec (count (i, j)) (qs_U li) <= 2 / INR (S (j - i)).
\end{code}
The |(i, j) `In` IJ| hypothesis is dropped, because the statement is also true if |(i, j) `NotIn` IJ|, per |sound_cmp_expec_0|. The |IndexSeq| premise expresses that |li| is a permutation of |[b...b+length l]| (for some |b|).

Again, the proof is by induction matching |qs|'s recursion. In the base case, |li| is |nil|, and the left side of the inequality reduces to 0. In the recursive case, |qs| unfolds:
\begin{code}
monoid_expec (count (i, j)) (
    pi <- pick [0 ... n];
    let pivot := nth li pi in
    part <- partition_U pivot (remove li pi);
    low <- qs_U (part Lt);
    upp <- qs_U (part Gt);
    ret (low ++ pivot :: part Eq ++ upp)
  ) <= 2 / INR (S (j - i))
\end{code}
Since |cmp_U| is deterministic, |partition_U| is deterministic here as well. Furthermore, since we know exactly what monadic effects |partition| has in this case, we can split those effects off and then revert to simple uneffectful |filter| passes. Finally, the outer |monoid_expec| can be partially evaluated because of the immediately visible |pick|. Using these observations, the goal can be rewritten into a form that uses less monadic indirection:

\begin{code}
avg (map (monoid_expec (count (i, j)) fcmp (fun pi =>
    let pivot := nth li pi in
    let rest := remove li pi in
    ne_tree.map (map_fst (++ map (U.unordered_nat_pair pivot) rest)) (
      lower <- qs_U (filter ((= Lt) fcmp lookup_cmp pivot) rest);
      upper <- qs_U (filter ((= Gt) fcmp lookup_cmp pivot) rest);
      ret (lower ++ (pivot :: filter ((= Eq) fcmp lookup_cmp pivot) rest) ++ upper)
    ))) [0...n]) <= 2 / INR (S (j - i)).
\end{code}
Here, |map_fst| applies a function to a pair's first component.
% todo: get this [0...n]/[0...n-1] stuff right.

We now distinguish between five different cases that can occur for the nondeterministically picked |pivot|; it can either be less than |i|, equal to |i|, between |i| and |j|, equal to |j|, or greater than |j|. Each case occurs a certain number of times, and has an associated expected number of |(i, j)| comparisons (coming either from the |map_fst| term representing the |partition| pass, or from the two recursive |qs_U| calls). To represent this split, we first rewrite the right side of the inequality to\begin{code}(2 / S (j - i) * (i - b) + 1 + 0 + 1 + 2 / S (j - i) * (b + n - j)) / S n.\end{code}
This form reflects the facts that
\begin{itemize}
\item the case where |pivot| is less than |i| occurs |i - b| times, and in each instance, the expected number of |(i, j)| comparisons is no more than |2 / S (j - i)|;
\item the case where the |pivot| is equal to |i| occurs once, and in this case no more than a single |(i, j)| comparison is expected;
\item in the case where |pivot| lies between |i| and |j|, the number of expected |(i, j)| comparisons is 0, and consequently it does not matter how many times this case occurs;
\item the case where the |pivot| is equal to |j| occurs once, and in this case no more than a single |(i, j)| comparison is expected;
\item the case where the |pivot| is greater than |j| occurs |b + n - j| times, and in each instance, the expected number of |(i, j)| comparisons is no more than |2 / S (j - i)|.
\end{itemize}
With the right side of the inequality in this form, we unfold the |avg| application on the left into |sum (...) / S n|, and then cancel the division by |S n| on both sides. Next, to actually realize the split, we apply a specialized lemma stating that
\begin{code}
   forall b i j X f n (li: list nat)
     (g: [0..n] -> U X), IndexSeq b li ->
    b <= i < j < b + S n -> forall ca cb, 0 <= ca -> 0 <= cb ->
    (forall pi, nth li pi < i -> expec f (g pi) <= ca) ->
    (forall pi, nth li pi = i -> expec f (g pi) <= cb) ->
    (forall pi, i < nth li pi < j -> expec f (g pi) = 0) ->
    (forall pi, nth li pi = j -> expec f (g pi) <= cb) ->
    (forall pi, j < nth li pi -> expec f (g pi) <= ca) ->
      sum (map (expec f fcmp g) [0..n]) <=
        ca * (i - b) + cb + 0 + cb + ca * (b + n - j).
\end{code}
The proof of this lemma is somewhat tedious \todo{because..}.
% involving a lot of repetitive arguments about permutations, etc

Five subgoals remain after applying the above lemma---one for each of the listed cases. The first one reads
\begin{code}
  forall pi,
    let pivot := nth li pi in
    let rest := remove li pi in
      pivot < i ->
      monoid_expec (count (i, j))
        (ne_tree.map (map_fst (++ map (U.unordered_nat_pair pivot) rest)) (
          foo <- qs_U (filter ((= Lt) fcmp lookup_cmp pivot) rest);
          bar <- qs_U (filter ((= Gt) fcmp lookup_cmp pivot) rest);
          ret (foo ++ (pivot :: filter ((= Gt) fcmp lookup_cmp pivot) rest) ++ bar)))
        <= 2 / S (j - i).
  \end{code}
Rewriting using a lemma saying that
\begin{code}
  forall (A: Set) (g: m) (h: m -> nat) (t: MMT m NeTreeMonad A):
    MonoidHomomorphism h ->
    monoid_expec h (ne_tree.map (map_fst (monoid_mult m g)) t) =
    INR (h g) + monoid_expec t,
\end{code}
the head reduces to
\begin{code}
    count (i, j) (map (U.unordered_nat_pair pivot) rest) +
    monoid_expec (count (i, j))
      (foo <- qs_U (filter ((= Lt) fcmp lookup_cmp pivot) rest);
      bar <- qs_U (filter ((= Gt) fcmp lookup_cmp pivot) rest);
      ret  (foo ++ (nth v pi :: filter ((= Eq) fcmp lookup_cmp pivot) rest) ++ bar))
    <= 2 / S (j - i).
\end{code}
From |pivot < i| and |i < j|, we have |pivot < j|. Since each of the comparisons in |map (U.unordered_nat_pair pivot) rest| involves the pivot element, it follows that none of them can represent comparisons between |i| and |j|. Hence, the first term vanishes. Furthermore, since |count (i, j)| is a monoid homomorphism, |monoid_expec_plus| lets us distribute |monoid_expec|. Since the |ret| term does not produce any comparisons either (by definition), its |monoid_expec| term vanishes, too. What remains are the two recursive calls:

\begin{code}
monoid_expec (count (i, j))
  (qs_U (filter ((= Lt) fcmp lookup_cmp pivot) rest)) +
monoid_expec (count (i, j))
  (qs_U (filter ((= Gt) fcmp lookup_cmp pivot) rest)) <= 2 / INR (S (j - i))
\end{code}
All indices in the lower filtered part denote elements that compare less than the element denoted by the pivot. Since the former precede the latter in |sort l|, it must be the case that the indices are less than |pivot|. By |sound_cmp_expec_0|, it follows that the first |qs_U| term will produce no |(i, j)| comparisons, so the first |monoid_expec| term vanishes as well, leaving
\begin{code}
monoid_expec (count (i, j))
  (qs_U (filter ((= Gt) fcmp lookup_cmp pivot) rest)) <= 2 / INR (S (j - i)).
\end{code}
We now compare |nth (sort l) i| with |nth (sort l) pivot|.
\begin{itemize}
\item If the two are equal, then |i| will not occur in the |filter term|, allowing us to invoke |sound_cmp_expec_0| yet again.
\item If |nth (sort l) i < nth (sort l) pivot|, then we must have |i < pivot|, contradicting the assumption that |pivot < i|.
\item If |nth (sort l) i > nth (sort l) pivot|, then we apply the induction hypothesis. For this, it must be shown that the filter term is a proper contiguous index sequence, which we relegated to a lemma we won't show here.
\end{itemize}
This concludes the case where |i < pivot|. The case where |j < pivot| is symmetric. The other cases use similar arguments.

The proof is now complete.

\section{Final Remarks}
\label{conclusion}

In the interest of brevity, we have omitted innumerable details and lemmas in the description of the proof. Still, the parts shown are reasonably faithful to the actual formalization. For completeness, we briefly list some complicating factors that we have ignored. In some cases, resolving these took significant effort.

\begin{itemize}
\item We have pretended to have used ordinary natural numbers as indices into ordinary lists, completely ignoring the inescapable issues of index validity that could not be ignored in the actual formalization. There, we use vectors (lists whose size is part of their type) and bounded natural numbers in many places instead. Using these substantially reduces the amount of |i < length l| proofs that need to be produced, converted, and passed around, but this solution is still far from painless.
\item Using the |Program| facility to deal with quicksort's non-structural recursion was not completely as trivial as we made it out to be. To make proving the generated proof obligations possible, the types of |filter| and |partition| had to be sigma-decorated with modest length guarantees, because the opacity of the unspecified monad's |bind| operation prevented |Program| from being able to ``see'' the relation between the function's parameters and the arguments it passed in its recursive calls.
\item Using the induction principles corresponding to the definitions produced by |Program| for a function already defined with two layers of monadicity quickly became unwieldy. To deal with this, we defined a series of specialized induction principles for specific instances of |qs|, which put the recursive proof obligation in as simple terms as possible, with as little monadic indirection as possible, using among other things the observations regarding determinism of the comparison operation, as described in section \ref{finishing}.
\end{itemize}

For all the gruesome details, we refer the interested reader to the Coq source files.

The shallow monadic embedding provides a simple but effective representation of the algorithm. The parameterization of the monad makes the representation very flexible, allowing a single definition to be instantiated either with basic monads (like the identity monad or bare nondeterminism monads) to get a non-instrumented version suitable for extraction and correctness proofs, or with monads that use |MMT| to add operation-counting, to support our complexity proofs.

Furthermore, since the shallowness of the embedding lets us re-use all standard Coq data types and facilities, including the powerful |Program Fixpoint| command, the actual algorithm definition itself is reasonably clean.

The |MMT| monoid monad transformer provided the ``glue'' to add instrumentation onto a base monad. Its use of a monoid to represent the operation ``counter'' let us use a single set of lemmas (about |monoid_expec|) for |NDP| and |U|, as both were instances of the |M_ne_tree| monad transformed with |MMT|, differing only in the monoid used. Indeed, the relative ease with which we could transform the expectancy lemma into the |U| monad, a monad highly specialized for the specific order-index based counting scheme we used, further attests to the flexibility of the combination of a monadic representation and the |MMT| monad transformer.

\todo{Paragraph saying that the formalized proof is faithful to the original proof, except for the part where we dropped the duplicate elements assumption. The purely mathematical part could be directly transcribed. The only theory we had to add served to support a formal treatment of the parts that the original clearly took for granted.}

% old passage that may yet be useful in some form or another:
%    Calling it an embedding almost seems misplaced, since the algorithm definitions are essentially just monadically expressed functional programs in Coq's calculus. Furthermore, since monads and monad transformers have been used in functional programming for decades, the basic idea should be immediately clear to any functional programmer. Still, it is worth noting that this pleasing convergence of subject and object languages is due solely to the fact that Coq is based on type theory.

For future work, an interesting next challenge is to try and formalize a (likely more complex) proof that the $O(n \log n)$ bound holds also for deterministic quicksorts (with sensible pivot selection strategies).

\bibliographystyle{plain}
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{paper}

\end{document}
